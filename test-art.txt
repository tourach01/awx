#!/usr/bin/env bash
set -euo pipefail

# =========================
# Config / Auth
# =========================
ARTI_URL="${ARTI_URL:-https://artifactory.example.com}"
# "artifactory" => https://host/artifactory/api/...
# "root"        => https://host/api/...
ARTI_API_BASE="${ARTI_API_BASE:-artifactory}"

ARTI_TOKEN="${ARTI_TOKEN:-}"   # Bearer (Access/Identity token)
ARTI_USER="${ARTI_USER:-}"     # Basic
ARTI_PASS="${ARTI_PASS:-}"     # Basic

# =========================
# Helpers
# =========================
usage() {
  cat <<'EOF'
Usage:
  MODE 1: Copier un dossier entier (récursif) en 1 appel
    artifactory-copy.sh folder --from REPO_A/path/source --to REPO_B/path/dest [--dry]

  MODE 2: Copier un sous-ensemble via AQL (liste -> copy)
    artifactory-copy.sh aql --from REPO_A/path/prefix --to REPO_B/path/prefix \
      [--name-glob "*.jar"] [--since "YYYY-MM-DD"] [--props "k=v;k2=v2"] [--dry] \
      [--rewrite-from "A"] [--rewrite-to "B"]

  MODE 3: AQL-SAFE (ignore sha1; compare taille & 'modified')
    artifactory-copy.sh aql-safe --from REPO_A/path/prefix --to REPO_B/path/prefix \
      [--name-glob "*.jar"] [--since "YYYY-MM-DD"] [--props "k=v;k2=v2"] [--dry] \
      [--rewrite-from "A"] [--rewrite-to "B"]

Notes:
  - --dry : active le dry-run côté /api/copy (?dry=1)
  - --rewrite-from/--rewrite-to : remplace un préfixe de path côté destination.
  - Écrasement (aql-safe) si: destination absente OU size différent OU source plus récente.
EOF
}

die(){ echo "ERR: $*" >&2; exit 1; }

auth_args=()
if [[ -n "$ARTI_TOKEN" ]]; then
  auth_args=(-H "Authorization: Bearer ${ARTI_TOKEN}")
elif [[ -n "${ARTI_USER}" && -n "${ARTI_PASS}" ]]; then
  auth_args=(-u "${ARTI_USER}:${ARTI_PASS}")
else
  die "Fournis ARTI_TOKEN ou ARTI_USER/ARTI_PASS"
fi

api_base() {
  local path="$1" # ex: "search/aql"
  if [[ "$ARTI_API_BASE" == "root" ]]; then
    printf "%s/api/%s" "${ARTI_URL%/}" "$path"
  else
    printf "%s/artifactory/api/%s" "${ARTI_URL%/}" "$path"
  fi
}

urlenc() {
  local s="$1" out="" c
  for ((i=0;i<${#s};i++)); do
    c="${s:i:1}"
    [[ "$c" =~ [a-zA-Z0-9.~_-] ]] && out+="$c" || printf -v out '%s%%%02X' "$out" "'$c"
  done
  printf '%s' "$out"
}

to_epoch() {
  # Convertit une date ISO en epoch (secondes). Renvoie vide si échec.
  local d="$1"
  [[ -z "$d" ]] && { echo ""; return; }
  date -d "$d" +%s 2>/dev/null || echo ""
}

# =========================
# Parse args
# =========================
MODE="${1:-}"; shift || true
[[ -n "${MODE}" ]] || { usage; exit 1; }

FROM=""; TO=""; NAME_GLOB=""; SINCE=""; PROPS=""
DRY=0; REW_FROM=""; REW_TO=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --from) FROM="$2"; shift 2;;
    --to) TO="$2"; shift 2;;
    --name-glob) NAME_GLOB="$2"; shift 2;;
    --since) SINCE="$2"; shift 2;;
    --props) PROPS="$2"; shift 2;;
    --dry) DRY=1; shift;;
    --rewrite-from) REW_FROM="$2"; shift 2;;
    --rewrite-to) REW_TO="$2"; shift 2;;
    -h|--help) usage; exit 0;;
    *) echo "Arg inconnu: $1"; usage; exit 1;;
  esac
done

[[ -n "$FROM" && -n "$TO" ]] || die "--from et --to requis (repo/path)"

SRC_REPO="${FROM%%/*}"
SRC_PATH="${FROM#*/}"      # peut être vide si racine
DST_REPO="${TO%%/*}"
DST_PATH="${TO#*/}"

# =========================
# AQL builder (items.find)
# =========================
build_aql() {
  local pfx="$SRC_PATH"
  [[ -z "$pfx" ]] && pfx="."
  local aql='items.find({'
  aql+='"repo":{"$eq":"'"$SRC_REPO"'"},'
  aql+='"path":{"$match":"'"$pfx"'*"},'
  aql+='"type":{"$eq":"file"}'
  if [[ -n "$NAME_GLOB" ]]; then
    aql+=',"name":{"$match":"'"$NAME_GLOB"'"}'
  fi
  if [[ -n "$SINCE" ]]; then
    aql+=',"modified":{"$gt":"'"$SINCE"'"}'
  fi
  if [[ -n "$PROPS" ]]; then
    IFS=';' read -r -a kvs <<<"$PROPS"
    for kv in "${kvs[@]}"; do
      local k="${kv%%=*}"; local v="${kv#*=}"
      aql+=',"@'"$k"'":{"$eq":"'"$v"'"}'
    done
  fi
  aql+='}).include("repo","path","name","size","modified","type")'
  printf "%s" "$aql"
}

# =========================
# API helpers
# =========================
aql_search() {
  local aql="$1"
  local url; url="$(api_base "search/aql")"
  curl -ksfSL -X POST "${auth_args[@]}" -H "Content-Type: text/plain" \
    "$url" --data-binary "$aql"
}

copy_one() {
  local src_repo="$1" src_rel="$2" dst_repo="$3" dst_dir="$4" dry="$5"
  local src_enc dst_enc url
  src_enc="$(urlenc "$src_rel")"
  dst_enc="$(urlenc "${dst_repo}/${dst_dir}")"
  url="$(api_base "copy/${src_repo}/${src_enc}")?to=${dst_enc}"
  [[ "$dry" -eq 1 ]] && url="${url}&dry=1"
  curl -ksfSL -X POST "${auth_args[@]}" "$url" >/dev/null
}

get_dst_meta() {
  # Renvoie "size<TAB>modified" ou vide si absent.
  local repo="$1" path="$2" name="$3"
  local aql='items.find({"repo":{"$eq":"'"$repo"'"},"path":{"$eq":"'"$path"'"},"name":{"$eq":"'"$name"'"}, "type":{"$eq":"file"}})'
  aql+='.include("size","modified")'
  aql_search "$aql" | jq -r 'if (.results|length)>0 then (.results[0].size|tostring)+"\t"+(.results[0].modified//"") else empty end'
}

rewrite_path_if_needed() {
  local in="$1"
  if [[ -n "$REW_FROM" && -n "$REW_TO" ]]; then
    printf '%s' "${in/$REW_FROM/$REW_TO}"
  else
    printf '%s' "$in"
  fi
}

# =========================
# Modes
# =========================
case "$MODE" in
  folder)
    SRC_PATH_ENC="$(urlenc "$SRC_PATH")"
    TO_ENC="$(urlenc "$TO")"
    DRY_PARAM=$([[ $DRY -eq 1 ]] && echo "&dry=1" || echo "")
    URL="$(api_base "copy/${SRC_REPO}/${SRC_PATH_ENC}")?to=${TO_ENC}${DRY_PARAM}"
    echo ">> COPY FOLDER: ${FROM} -> ${TO} (dry=${DRY})"
    curl -ksfSL -X POST "${auth_args[@]}" "$URL"
    echo; echo "OK"
    ;;

  aql|aql-safe)
    AQL="$(build_aql)"
    echo ">> AQL search…"
    RESP="$(aql_search "$AQL")"
    COUNT="$(echo "$RESP" | jq '.results|length')"
    echo ">> ${COUNT} artefacts trouvés"
    [[ "$COUNT" -gt 0 ]] || exit 0

    echo "$RESP" \
    | jq -r '.results[] | [.repo,.path,.name, (.size|tostring), (.modified//""), .type] | @tsv' \
    | while IFS=$'\t' read -r repo path name size_src modified_src type; do
        # path destination (avec réécriture éventuelle)
        new_path="$(rewrite_path_if_needed "$path")"
        if [[ -n "$DST_PATH" && "$DST_PATH" != "." ]]; then
          base="${SRC_PATH:-.}"; [[ "$base" == "." ]] && base=""
          suffix="$path"; [[ -n "$base" ]] && suffix="${path#${base}}"
          suffix="${suffix#/}"
          new_path="${DST_PATH%/}/${suffix}"
          new_path="$(rewrite_path_if_needed "$new_path")"
        fi

        src_rel="${path}/${name}"
        echo " - ${SRC_REPO}/${src_rel} -> ${DST_REPO}/${new_path}/${name}"

        if [[ "$MODE" == "aql-safe" ]]; then
          # Récupérer meta dest
          meta_dst="$(get_dst_meta "$DST_REPO" "$new_path" "$name" || true)"
          if [[ -n "$meta_dst" ]]; then
            size_dst="$(cut -f1 <<<"$meta_dst")"
            modified_dst="$(cut -f2 <<<"$meta_dst")"
          else
            size_dst=""; modified_dst=""
          fi

          # Décision: copier si dest absente OU size diff OU src plus récent
          copy_needed=0
          if [[ -z "$meta_dst" ]]; then
            copy_needed=1
          elif [[ "$size_src" != "$size_dst" ]]; then
            copy_needed=1
          else
            # comparer modified (epoch); si parsing impossible, on ne copie pas si tailles identiques
            src_epoch="$(to_epoch "$modified_src")"
            dst_epoch="$(to_epoch "$modified_dst")"
            if [[ -n "$src_epoch" && -n "$dst_epoch" && "$src_epoch" -gt "$dst_epoch" ]]; then
              copy_needed=1
            fi
          fi

          if [[ "$copy_needed" -eq 0 ]]; then
            echo "   = SKIP (identique ou destination plus récente)"
            continue
          fi
        fi

        copy_one "$SRC_REPO" "$src_rel" "$DST_REPO" "$new_path" "$DRY" || {
          echo "   !! échec copie" >&2
        }
      done
    echo "OK (mode=${MODE}, dry=${DRY})"
    ;;

  *)
    usage; exit 1;;
esac
