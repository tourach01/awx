#!/usr/bin/env bash
# aap_helpers.sh — fonctions utilitaires pour aap_load_inventory_awx.sh
# Dépendances: bash >= 4, jq, curl, awx (recommandé mais pas obligatoire pour certaines fonctions)
# Variables d'env possibles: URL, TOKEN (ou USER+PASS), AAP_INSECURE, BULK_BATCH_SIZE

# ============================ Helpers génériques ==============================

# Normalise une liste CSV passée en plusieurs arguments ("a,b" "c" ...)
# Usage:
#   normalize_csv_list [-u] OUTVAR INPUT1 [INPUT2 ...]
#   -u : dédoublonne (préserve l'ordre)
normalize_csv_list() {
  local dedupe="false"
  if [[ "${1:-}" == "-u" ]]; then
    dedupe="true"; shift
  fi
  local -n _out="$1"; shift || true
  _out=()

  declare -A _seen=()
  local IFS_SAVE=$IFS
  IFS=,
  for chunk in "$@"; do
    for tok in $chunk; do
      tok="${tok//$'\r'/}"
      tok="$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' <<<"$tok")"
      [[ -z "$tok" ]] && continue
      if [[ "$dedupe" == "true" ]]; then
        [[ -n "${_seen[$tok]+x}" ]] && continue
        _seen["$tok"]=1
      fi
      _out+=("$tok")
    done
  done
  IFS=$IFS_SAVE
}

# =============================== Helpers jq ==================================

first_id() {
  jq -r '
    if type=="array" and length>0 then
      .[0].id // empty
    elif type=="object" and has("results") and (.results|type=="array") and ((.results|length)>0) then
      .results[0].id // empty
    elif type=="object" and has("id") then
      .id // empty
    else empty end
  '
}

count_items() {
  jq -r '
    if type=="array" then length
    elif type=="object" and has("count") then .count
    elif type=="object" and has("results") and (.results|type=="array") then (.results|length)
    else 0 end
  '
}

list_names() {
  jq -r '
    if type=="array" then .[]?.name
    elif type=="object" and has("results") then .results[]?.name
    else empty end
  '
}

# ====================== HTTP helpers pour l'API Tower/AWX ====================

# Ajoute les bons headers et passe TOUTES les options supplémentaires à curl.
# IMPORTANT: "$@" avant l'URL pour permettre --request/--data passés par l'appelant.
_aap_curl_json() {
  local url="$1"; shift || true
  local -a args=(-sS --fail --header "Content-Type: application/json")
  [[ -n "${AAP_INSECURE:-}" ]] && args+=(-k)
  if [[ -n "${TOKEN:-}" ]]; then
    args+=(--header "Authorization: Bearer ${TOKEN}")
  elif [[ -n "${USER:-}" && -n "${PASS:-}" ]]; then
    args+=(-u "${USER}:${PASS}")
  fi
  curl "${args[@]}" "$@" "$url"
}

_aap_curl_post_json() {
  local url="$1" data="$2"
  _aap_curl_json "$url" --request POST --header "Accept: application/json" --data "$data"
}

# ======================= Inventaires / Groupes / Hôtes =======================

create_inventory() {
  # $1 = org_id, $2 = name
  local org_id="$1" name="$2"
  awx inventories create --name "${name}" --organization "${org_id}" -f json --conf.color False </dev/null |
    jq -r '.id // empty'
}

ensure_group() {
  # $1 = inventory_id, $2 = group_name
  local inv_id="$1" group_name="$2"
  local gid
  gid=$(awx groups list --inventory "${inv_id}" --name "${group_name}" -f json --conf.color False </dev/null | first_id || true)
  if [[ -z "${gid}" ]]; then
    gid=$(awx groups create --inventory "${inv_id}" --name "${group_name}" -f json --conf.color False </dev/null | jq -r '.id // empty')
  fi
  printf '%s' "${gid}"
}

first_or_create_host() {
  # (ancienne méthode non-bulk — conservée pour éventuel fallback)
  local inv_id="$1" host="$2"
  local hid
  hid=$(awx hosts list --inventory "${inv_id}" --name "${host}" -f json --conf.color False </dev/null | first_id || true)
  if [[ -z "${hid}" ]]; then
    hid=$(awx hosts create --inventory "${inv_id}" --name "${host}" -f json --conf.color False </dev/null | jq -r '.id // empty' || true)
  fi
  printf '%s' "${hid}"
}

# Compte rapide des hôtes d'un inventaire via API (champ .count)
_get_inventory_hosts_count() {
  # $1 = inventory_id
  local base="${URL%/}"
  local json
  if ! json=$(_aap_curl_json "${base}/api/v2/hosts/?inventory=$1&page_size=1"); then
    echo 0
    return
  fi
  jq -r 'if type=="object" and has("count") then .count else 0 end' <<<"$json"
}

# Associe des hôtes à un groupe, en résolvant leurs IDs par leurs noms
_associate_hosts_to_group_by_names() {
  # $1 = inventory_id, $2 = group_id, $3.. = noms des hôtes
  local inv_id="$1" group_id="$2"; shift 2
  local -a WANT_NAMES=( "$@" )
  ((${#WANT_NAMES[@]})) || return 0

  declare -A WANT=()
  local n; for n in "${WANT_NAMES[@]}"; do WANT["$n"]=1; done

  local base="${URL%/}"
  local list_url="${base}/api/v2/hosts/?inventory=${inv_id}&page_size=200"
  declare -A NAME2ID=()

  while [[ -n "$list_url" ]]; do
    local json
    if ! json=$(_aap_curl_json "$list_url"); then
      echo "Échec GET hosts inventory=${inv_id}" >&2
      break
    fi
    while IFS=$'\t' read -r _id _name; do
      [[ -z "${WANT[$_name]+x}" ]] && continue
      NAME2ID["$_name"]="${_id}"
    done < <(jq -r '
      (if type=="object" and has("results") then .results else . end)
      | .[]? | "\(.id)\t\(.name)"' <<<"$json")

    list_url=$(jq -r '
      if type=="object" and has("next") and (.next!=null) then .next else "" end
    ' <<<"$json")
  done

  local assoc_url="${base}/api/v2/groups/${group_id}/hosts/"
  local done_count=0 miss_count=0
  for n in "${WANT_NAMES[@]}"; do
    local hid="${NAME2ID[$n]:-}"
    if [[ -z "$hid" ]]; then
      ((miss_count++))
      echo "  ! host '${n}' introuvable (inventaire ${inv_id})" >&2
      continue
    fi
    _aap_curl_post_json "$assoc_url" "$(jq -c --argjson id "$hid" '{id:$id}')" >/dev/null || true
    ((done_count++))
  done
  echo "Association groupe: ${done_count} lié(s), ${miss_count} introuvable(s)."
}

# ======================= BULK: création d'hôtes ==============================

# Remplace l'ancienne add_hosts_into_inventory: envoie des lots vers /bulk/host_create/
bulk_add_hosts_into_inventory() {
  # $1 = inventory_id, $2 = group_id (ou vide), $3.. = liste d'hôtes
  local inv_id="$1" group_id="${2:-}"; shift 2
  local base="${URL%/}"
  local bulk_url="${base}/api/v2/bulk/host_create/"
  local batch_size="${BULK_BATCH_SIZE:-200}"

  declare -A SEEN=()
  local HOSTS=() h
  for h in "$@"; do
    [[ -z "$h" ]] && continue
    [[ -n "${SEEN[$h]+x}" ]] && continue
    SEEN["$h"]=1
    HOSTS+=("$h")
  done
  ((${#HOSTS[@]})) || { echo "Aucun hôte à créer (bulk)."; return 0; }

  echo "Création bulk de ${#HOSTS[@]} hôte(s) dans inventory id=${inv_id}…"

  local i=0 created_total=0
  local count_before_all
  count_before_all=$(_get_inventory_hosts_count "$inv_id")

  while (( i < ${#HOSTS[@]} )); do
    local end=$(( i + batch_size ))
    (( end > ${#HOSTS[@]} )) && end=${#HOSTS[@]}

    local names_json payload resp
    names_json=$(
      printf '%s\n' "${HOSTS[@]:i:end-i}" | jq -R -s 'split("\n") | map(select(length>0))'
    )
    payload=$(jq -cn --argjson inv "$inv_id" --argjson names "$names_json" \
      '{inventory:$inv, hosts: ($names | map({name:.}))}')

    local count_before_batch
    count_before_batch=$(_get_inventory_hosts_count "$inv_id")

    if ! resp=$(_aap_curl_post_json "$bulk_url" "$payload"); then
      echo "Échec bulk host_create (lot ${i}-${end})." >&2
      return 1
    fi

    local created_this
    created_this=$(
      jq -r '
        if type!="object" then 0
        else
          if has("created") and (.created|type=="array") then (.created|length)
          elif has("hosts") and (.hosts|type=="object") and (.hosts|has("created")) then
            ( .hosts.created | if type=="array" then length elif type=="number" then . else 0 end )
          elif has("results") and (.results|type=="array") then
            ([ .results[] | select((.created==true) or (.changed==true)) ] | length)
          else 0 end
        end
      ' <<<"$resp"
    )

    if [[ -z "$created_this" || "$created_this" == "0" ]]; then
      local count_after_batch
      count_after_batch=$(_get_inventory_hosts_count "$inv_id")
      local delta=$(( count_after_batch - count_before_batch ))
      (( delta < 0 )) && delta=0
      created_this=$delta
    fi

    (( created_total += created_this ))
    i=$end
  done

  local count_after_all
  count_after_all=$(_get_inventory_hosts_count "$inv_id")
  local net_delta=$(( count_after_all - count_before_all ))
  (( net_delta < 0 )) && net_delta=0

  echo "Création bulk terminée. ${created_total} hôte(s) créés (delta inventaire: ${net_delta})."

  if [[ -n "$group_id" ]]; then
    echo "Association des hôtes au groupe id=${group_id}…"
    _associate_hosts_to_group_by_names "$inv_id" "$group_id" "${HOSTS[@]}"
  fi
}

# ====================== Failed hosts (summaries / events) ====================

# Essai via CLI 'job_host_summaries' si dispo; sinon fallback 'job_events'
_collect_failed_hosts_via_summaries() {
  local job_id="$1" page=1 any=0 json
  while :; do
    if ! json=$(awx job_host_summaries list --job "${job_id}" --page "${page}" -f json --conf.color False </dev/null 2>/dev/null); then
      return 1
    fi
    printf '%s' "${json}" | jq -r '
      (if type=="object" and has("results") then .results else . end)
      | .[]?
      | select((.failed==true) or (.status=="failed") or (.failed==1))
      | .host_name'
    any=1
    local has_next
    has_next=$(printf '%s' "${json}" | jq -r 'if type=="object" and has("next") then (.next!=null) else "false" end')
    [[ "${has_next}" == "true" ]] || break
    ((page++))
  done
  [[ ${any} -eq 1 ]]
}

_collect_failed_hosts_via_events() {
  local job_id="$1" page=1 json
  while :; do
    json=$(awx job_events list --job "${job_id}" \
            --event runner_on_failed --event runner_on_unreachable \
            --page "${page}" -f json --conf.color False </dev/null)
    printf '%s' "${json}" | jq -r '
      (if type=="object" and has("results") then .results else . end)
      | .[]? | .host_name // empty'
    local has_next
    has_next=$(printf '%s' "${json}" | jq -r 'if type=="object" and has("next") then (.next!=null) else "false" end')
    [[ "${has_next}" == "true" ]] || break
    ((page++))
  done
}

collect_failed_hosts_from_job() {
  local job_id="$1"
  if _collect_failed_hosts_via_summaries "${job_id}"; then
    return 0
  fi
  _collect_failed_hosts_via_events "${job_id}"
}

# Variante API directe (sans CLI) — si besoin
collect_failed_hosts_via_summaries_api() {
  local job_id="${1:?usage: collect_failed_hosts_via_summaries_api <job_id>}"
  local base="${URL%/}"
  local url="${base}/api/v2/jobs/${job_id}/job_host_summaries/?page_size=200"
  local any=0

  while [[ -n "${url}" ]]; do
    local json
    if ! json=$(_aap_curl_json "${url}"); then
      echo "Erreur: appel API échoué sur ${url}" >&2
      return 1
    fi
    local names
    names=$(printf '%s' "${json}" | jq -r '
      (if type=="object" and has("results") then .results else . end)
      | map( select((.failed==true) or (.failed==1) or (.status=="failed")) )
      | .[] | (.host_name // (.summary_fields.host.name // empty)) | select(.!="")')
    if [[ -n "${names}" ]]; then
      any=1
      printf '%s\n' "${names}"
    fi
    local next
    next=$(printf '%s' "${json}" | jq -r 'if type=="object" and has("next") and (.next!=null) then .next else "" end')
    url="${next}"
  done

  [[ ${any} -eq 1 ]] && return 0 || return 2
}

# ======================== Affichage stdout d'un job ==========================

show_job_stdout() {
  # $1 = job_id
  local job_id="${1:?usage: show_job_stdout <job_id>}"
  if awx jobs stdout "${job_id}" --conf.color False </dev/null; then
    return 0
  fi
  local base="${URL%/}"
  local url="${base}/api/v2/jobs/${job_id}/stdout/?format=txt_download"
  _aap_curl_json "${url}"
}

# ===================== Extra-vars & lancement de template ====================

# Génère un argument --extra_vars robuste (fichier @tmp si nécessaire)
prepare_extra_vars_arg() {
  local evars="$1"
  if [[ -z "$evars" ]]; then
    return 0
  fi
  if [[ "$evars" == @* ]]; then
    local path="${evars#@}"
    if [[ -f "$path" ]]; then
      printf '@%s' "$path"
      return 0
    fi
  fi
  if [[ "$evars" == *$'\n'* || "$evars" == *:* || "$evars" == *"{"* ]]; then
    local tf; tf="$(mktemp -t aap_extra_vars_XXXXXX.yml)"
    printf '%s\n' "$evars" > "$tf"
    printf '@%s' "$tf"
    return 0
  fi
  local tf; tf="$(mktemp -t aap_extra_vars_XXXXXX.yml)"
  {
    for pair in $evars; do
      local key="${pair%%=*}"
      local val="${pair#*=}"
      val="${val//\"/\\\"}"
      printf '%s: "%s"\n' "$key" "$val"
    done
  } > "$tf"
  printf '@%s' "$tf"
}

# Lancement d'un template, avec:
# - contrôle verbosité (logs live ou attente silencieuse)
# - credentials ajoutés
# - niveau de verbosity (0..5)
# - export des failed-hosts vers inventaire si demandé
launch_template_with_inventory() {
  # $1..$8 = comme avant
  # $9  = verbose ("true"/"false")
  # $10 = credential IDs "12 34" (peut être vide)
  # $11 = verbosity level "0..5" (peut être vide)
  local template_arg="$1" inv_id="$2" extra_vars="$3" show_failed="$4" failed_dest="$5" purge_dest="$6" org_id="$7" dest_group="$8" verbose="${9:-false}"
  shift 9
  local cred_ids_ws="${1:-}"; shift || true
  local verbosity_level="${1:-}"

  local tpl_id
  if [[ "${template_arg}" =~ ^[0-9]+$ ]]; then
    tpl_id="${template_arg}"
  else
    tpl_id=$(awx job_templates list --name "${template_arg}" -f json --conf.color False </dev/null | first_id || true)
    [[ -z "${tpl_id}" ]] && { echo "Job Template '${template_arg}' introuvable." >&2; return 1; }
  fi

  local extra_arg=""
  if [[ -n "${extra_vars}" ]]; then
    extra_arg="$(prepare_extra_vars_arg "${extra_vars}")"
  fi

  local args=( job_templates launch "${tpl_id}" --inventory "${inv_id}" -f json --conf.color False )
  [[ -n "${extra_arg}" ]] && args+=( --extra_vars "${extra_arg}" )

  if [[ -n "${cred_ids_ws}" ]]; then
    local cid
    for cid in ${cred_ids_ws}; do
      [[ -n "${cid}" ]] && args+=( --credential "${cid}" )
    done
  fi

  if [[ -n "${verbosity_level}" ]]; then
    args+=( --verbosity "${verbosity_level}" )
  fi

  local job_json job_id status
  job_json=$(awx "${args[@]}" </dev/null)
  job_id=$(printf '%s' "${job_json}" | jq -r '.id // empty')
  [[ -z "${job_id}" ]] && { echo "Échec du lancement du job." >&2; printf '%s\n' "${job_json}" >&2; return 1; }

  if [[ "${verbose}" == "true" ]]; then
    echo "Job lancé: id=${job_id}. Affichage en direct…"
    awx jobs monitor "${job_id}" --conf.color False </dev/null || true
    status="$(awx jobs get "${job_id}" -f json --conf.color False </dev/null | jq -r '.status // empty')"
  else
    echo "Job lancé: id=${job_id}. Attente silencieuse de la fin…"
    while :; do
      status=$(awx jobs get "${job_id}" -f json --conf.color False </dev/null | jq -r '.status // empty')
      case "$status" in
        successful|failed|error|canceled) break ;;
        *) sleep 2 ;;
      esac
    done
  fi

  local job_ok=0
  if [[ "$status" == "successful" ]]; then
    echo "Statut final du job ${job_id}: successful."
  else
    echo "Statut final du job ${job_id}: ${status}." >&2
    job_ok=1
  fi

  if [[ "${show_failed}" == "true" ]]; then
    echo "Hôtes en échec pour le job ${job_id}:"
    print_failed_hosts "${job_id}"
  fi

  if [[ -n "${failed_dest}" ]]; then
    echo "Collecte des failed-hosts du job pour alimentation de '${failed_dest}'…"
    mapfile -t FAILED_HOSTS < <(collect_failed_hosts_from_job "${job_id}" | sort -u)
    if ((${#FAILED_HOSTS[@]})); then
      local dest_inv_id
      dest_inv_id=$(awx inventories list --name "${failed_dest}" --organization "${org_id}" -f json --conf.color False </dev/null | first_id || true)
      [[ -z "${dest_inv_id}" ]] && dest_inv_id=$(create_inventory "${org_id}" "${failed_dest}")
      [[ "${purge_dest}" == "true" ]] && purge_inventory_hosts "${dest_inv_id}"
      local dest_group_id=""
      [[ -n "${dest_group}" ]] && dest_group_id=$(ensure_group "${dest_inv_id}" "${dest_group}")
      add_hosts_into_inventory "${dest_inv_id}" "${dest_group_id}" "${FAILED_HOSTS[@]}"  # fallback per-host OK ici
    else
      echo "Aucun failed-host détecté pour ce job."
    fi
  fi

  return ${job_ok}
}

# Purge des hôtes d'un inventaire (delete hosts)
purge_inventory_hosts() {
  local inv_id="$1"
  echo "Purge des hôtes de l'inventaire id=${inv_id}…"
  local page=1 deleted=0
  while :; do
    local json ids
    json=$(awx hosts list --inventory "${inv_id}" --page "${page}" -f json --conf.color False </dev/null)
    ids=$(printf '%s' "${json}" | jq -r '
      (if type=="object" and has("results") then .results else . end)
      | .[]? | .id')
    [[ -z "${ids}" ]] && break
    while IFS= read -r hid; do
      [[ -z "${hid}" ]] && continue
      awx hosts delete "${hid}" --conf.color False </dev/null || true
      ((deleted++))
    done <<< "${ids}"
    local has_next
    has_next=$(printf '%s' "${json}" | jq -r 'if type=="object" and has("next") then (.next!=null) else "false" end')
    [[ "${has_next}" == "true" ]] || break
    ((page++))
  done
  echo "Purge terminée: ${deleted} hôte(s) supprimé(s)."
}

# Affiche les hôtes en échec d'un job (utilise collect_failed_hosts_from_job)
print_failed_hosts() {
  local job_id="$1"
  local names
  names=$(collect_failed_hosts_from_job "${job_id}" | sort -u)
  if [[ -n "${names}" ]]; then
    printf '%s\n' "${names}"
  else
    echo "(aucun hôte en échec)"
  fi
}


------------------------------
------------------------------


  # -------------------- Credentials: union + remplacement Machine -------------
  # Récupérer les credentials déjà attachés au JT
  local current_cred_ids
  current_cred_ids=$(
    awx job_templates get "${tpl_id}" -f json --conf.color False </dev/null |
    jq -r '.summary_fields.credentials[]?.id' | tr '\n' ' '
  )

  # Séparer "Machine" (kind=ssh) et "non-Machine" pour les existants
  declare -a current_non_machine=()
  declare -a current_machine=()
  declare -A seen_ids=()

  local cid kind
  for cid in ${current_cred_ids}; do
    [[ -z "$cid" || -n "${seen_ids[$cid]+x}" ]] && continue
    kind="$(cred_kind "$cid")"
    if [[ "$kind" == "ssh" ]]; then
      current_machine+=("$cid")
    else
      current_non_machine+=("$cid")
    fi
    seen_ids["$cid"]=1
  done

  # Traiter les -K passés en ligne: séparer Machine vs non-Machine
  declare -a provided_machine=()
  declare -a provided_non_machine=()
  if [[ -n "${cred_ids_ws}" ]]; then
    local pid pkind
    for pid in ${cred_ids_ws}; do
      [[ -z "$pid" || -n "${seen_ids[$pid]+x}" ]] && continue
      pkind="$(cred_kind "$pid")"
      if [[ "$pkind" == "ssh" ]]; then
        provided_machine+=("$pid")
      else
        provided_non_machine+=("$pid")
      fi
      # on ne marque pas seen_ids ici pour laisser la dédup globale plus bas
    done
  fi

  # Politique:
  # - Machine: si au moins un fourni -> on REPLACE (on ignore les "current_machine"), on prend le 1er fourni
  #            sinon -> on GARDE les "current_machine" (tels quels)
  # - Non-Machine: union de current_non_machine ∪ provided_non_machine
  declare -a final_creds=()
  declare -A final_seen=()

  # Non-Machine d'abord (existants)
  for cid in "${current_non_machine[@]}"; do
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  done
  # puis Non-Machine fournis
  for cid in "${provided_non_machine[@]}"; do
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  done

  # Machine: remplacement si fourni, sinon conserver existants
  if ((${#provided_machine[@]} > 0)); then
    # prendre le 1er créd Machine fourni
    cid="${provided_machine[0]}"
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  else
    # garder les Machine existants
    for cid in "${current_machine[@]}"; do
      [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
    done
  fi

  # -------------------- Construire la commande de lancement -------------------
  local args=( job_templates launch "${tpl_id}" --inventory "${inv_id}" -f json --conf.color False )
  [[ -n "${extra_arg}" ]] && args+=( --extra_vars "${extra_arg}" )

  # IMPORTANT: utiliser --credentials (pluriel), répété pour chaque ID
  if ((${#final_creds[@]})); then
    for cid in "${final_creds[@]}"; do
      args+=( --credentials "$cid" )
    done
  fi

  # Verbosity (0..5) si fourni
  if [[ -n "${verbosity_level}" ]]; then
    args+=( --verbosity "${verbosity_level}" )
  fi




------------------------------
------------------------------
# Retourne le "kind" d'un credential (ssh, vault, scm, net, …)
cred_kind() {
  # $1 = credential_id
  local cid="${1:?usage: cred_kind <credential_id>}"
  awx credentials get "${cid}" -f json --conf.color False </dev/null | jq -r '.kind // empty'
}
------------------------------
------------------------------

launch_template_with_inventory() {
  # $1 = template_arg (id ou nom)
  # $2 = inventory_id
  # $3 = extra_vars string ou vide (ex: 'a=b c=d' ou '@file.yml' ou YAML/JSON inline)
  # $4 = show_failed ("true"/"false")
  # $5 = failed_dest_name (peut être vide)
  # $6 = purge_dest ("true"/"false")
  # $7 = org_id (pour créer failed_dest si besoin)
  # $8 = optional group name (associer dans dest)
  # $9 = verbose ("true"/"false") -> monitor si true, attente silencieuse sinon
  # $10 = credential IDs "12 34" (peut être vide)
  # $11 = verbosity level "0..5" (peut être vide)
  local template_arg="$1" inv_id="$2" extra_vars="$3" show_failed="$4" failed_dest="$5" purge_dest="$6" org_id="$7" dest_group="$8" verbose="${9:-false}"
  shift 9
  local cred_ids_ws="${1:-}"; shift || true
  local verbosity_level="${1:-}"

  # Résoudre l'ID du template
  local tpl_id
  if [[ "${template_arg}" =~ ^[0-9]+$ ]]; then
    tpl_id="${template_arg}"
  else
    tpl_id=$(awx job_templates list --name "${template_arg}" -f json --conf.color False </dev/null | first_id || true)
    [[ -z "${tpl_id}" ]] && { echo "Job Template '${template_arg}' introuvable." >&2; return 1; }
  fi

  # Préparer --extra_vars robuste
  local extra_arg=""
  if [[ -n "${extra_vars}" ]]; then
    extra_arg="$(prepare_extra_vars_arg "${extra_vars}")"
  fi

  # -------------------- Credentials: union + remplacement Machine -------------
  # Récupérer les credentials déjà attachés au JT
  local current_cred_ids
  current_cred_ids=$(
    awx job_templates get "${tpl_id}" -f json --conf.color False </dev/null |
    jq -r '.summary_fields.credentials[]?.id' | tr '\n' ' '
  )

  # Séparer "Machine" (kind=ssh) et "non-Machine" pour les existants
  declare -a current_non_machine=()
  declare -a current_machine=()
  declare -A seen_ids=()

  local cid kind
  for cid in ${current_cred_ids}; do
    [[ -z "$cid" || -n "${seen_ids[$cid]+x}" ]] && continue
    kind="$(cred_kind "$cid")"
    if [[ "$kind" == "ssh" ]]; then
      current_machine+=("$cid")
    else
      current_non_machine+=("$cid")
    fi
    seen_ids["$cid"]=1
  done

  # Traiter les -K passés en ligne: séparer Machine vs non-Machine
  declare -a provided_machine=()
  declare -a provided_non_machine=()
  if [[ -n "${cred_ids_ws}" ]]; then
    local pid pkind
    for pid in ${cred_ids_ws}; do
      [[ -z "$pid" || -n "${seen_ids[$pid]+x}" ]] && continue
      pkind="$(cred_kind "$pid")"
      if [[ "$pkind" == "ssh" ]]; then
        provided_machine+=("$pid")
      else
        provided_non_machine+=("$pid")
      fi
      # (on ne marque pas seen_ids ici : dédup générale plus bas)
    done
  fi

  # Politique:
  # - Machine: si au moins un fourni -> REPLACE (ignorer les current_machine), prendre le 1er fourni
  #            sinon -> GARDER les current_machine
  # - Non-Machine: union de current_non_machine ∪ provided_non_machine
  declare -a final_creds=()
  declare -A final_seen=()

  for cid in "${current_non_machine[@]}"; do
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  done
  for cid in "${provided_non_machine[@]}"; do
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  done

  if ((${#provided_machine[@]} > 0)); then
    cid="${provided_machine[0]}"
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  else
    for cid in "${current_machine[@]}"; do
      [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
    done
  fi

  # -------------------- Construire la commande de lancement -------------------
  local args=( job_templates launch "${tpl_id}" --inventory "${inv_id}" -f json --conf.color False )
  [[ -n "${extra_arg}" ]] && args+=( --extra_vars "${extra_arg}" )

  # IMPORTANT: utiliser --credentials (pluriel), répété pour chaque ID
  if ((${#final_creds[@]})); then
    for cid in "${final_creds[@]}"; do
      args+=( --credentials "$cid" )
    done
  fi

  # Verbosity (0..5) si fourni
  if [[ -n "${verbosity_level}" ]]; then
    args+=( --verbosity "${verbosity_level}" )
  fi

  # -------------------- Lancement + attente (silencieuse ou monitor) ---------
  local job_json job_id status
  job_json=$(awx "${args[@]}" </dev/null)
  job_id=$(printf '%s' "${job_json}" | jq -r '.id // empty')
  [[ -z "${job_id}" ]] && { echo "Échec du lancement du job." >&2; printf '%s\n' "${job_json}" >&2; return 1; }

  if [[ "${verbose}" == "true" ]]; then
    echo "Job lancé: id=${job_id}. Affichage en direct…"
    awx jobs monitor "${job_id}" --conf.color False </dev/null || true
    status="$(awx jobs get "${job_id}" -f json --conf.color False </dev/null | jq -r '.status // empty')"
  else
    echo "Job lancé: id=${job_id}. Attente silencieuse de la fin…"
    while :; do
      status=$(awx jobs get "${job_id}" -f json --conf.color False </dev/null | jq -r '.status // empty')
      case "$status" in
        successful|failed|error|canceled) break ;;
        *) sleep 2 ;;
      esac
    done
  fi

  local job_ok=0
  if [[ "$status" == "successful" ]]; then
    echo "Statut final du job ${job_id}: successful."
  else
    echo "Statut final du job ${job_id}: ${status}." >&2
    job_ok=1
  fi

  # -------------------- Failed hosts (affichage / destination) ----------------
  if [[ "${show_failed}" == "true" ]]; then
    echo "Hôtes en échec pour le job ${job_id}:"
    print_failed_hosts "${job_id}"
  fi

  if [[ -n "${failed_dest}" ]]; then
    echo "Collecte des failed-hosts du job pour alimentation de '${failed_dest}'…"
    mapfile -t FAILED_HOSTS < <(collect_failed_hosts_from_job "${job_id}" | sort -u)
    if ((${#FAILED_HOSTS[@]})); then
      local dest_inv_id
      dest_inv_id=$(awx inventories list --name "${failed_dest}" --organization "${org_id}" -f json --conf.color False </dev/null | first_id || true)
      [[ -z "${dest_inv_id}" ]] && dest_inv_id=$(create_inventory "${org_id}" "${failed_dest}")
      [[ "${purge_dest}" == "true" ]] && purge_inventory_hosts "${dest_inv_id}"
      local dest_group_id=""
      [[ -n "${dest_group}" ]] && dest_group_id=$(ensure_group "${dest_inv_id}" "${dest_group}")
      add_hosts_into_inventory "${dest_inv_id}" "${dest_group_id}" "${FAILED_HOSTS[@]}"  # fallback per-host OK ici
    else
      echo "Aucun failed-host détecté pour ce job."
    fi
  fi

  return ${job_ok}
}

---------------------------------
--------------------------------

launch_template_with_inventory() {
  # $1 = template_arg (id ou nom)
  # $2 = inventory_id
  # $3 = extra_vars string ou vide (ex: 'a=b c=d' ou '@file.yml' ou YAML/JSON inline)
  # $4 = show_failed ("true"/"false")
  # $5 = failed_dest_name (peut être vide)
  # $6 = purge_dest ("true"/"false")
  # $7 = org_id (pour créer failed_dest si besoin)
  # $8 = optional group name (associer dans dest)
  # $9 = verbose ("true"/"false") -> monitor si true, attente silencieuse sinon
  # $10 = credential IDs "12 34" (peut être vide)
  # $11 = verbosity level "0..5" (peut être vide)
  local template_arg="$1" inv_id="$2" extra_vars="$3" show_failed="$4" failed_dest="$5" purge_dest="$6" org_id="$7" dest_group="$8" verbose="${9:-false}"
  shift 9
  local cred_ids_ws="${1:-}"; shift || true
  local verbosity_level="${1:-}"

  # Résoudre l'ID du template
  local tpl_id
  if [[ "${template_arg}" =~ ^[0-9]+$ ]]; then
    tpl_id="${template_arg}"
  else
    tpl_id=$(awx job_templates list --name "${template_arg}" -f json --conf.color False </dev/null | first_id || true)
    [[ -z "${tpl_id}" ]] && { echo "Job Template '${template_arg}' introuvable." >&2; return 1; }
  fi

  # Préparer --extra_vars robuste
  local extra_arg=""
  if [[ -n "${extra_vars}" ]]; then
    extra_arg="$(prepare_extra_vars_arg "${extra_vars}")"
  fi

  # -------------------- Credentials: union + remplacement Machine -------------
  # Récupérer les credentials déjà attachés au JT
  local current_cred_ids
  current_cred_ids=$(
    awx job_templates get "${tpl_id}" -f json --conf.color False </dev/null |
    jq -r '.summary_fields.credentials[]?.id' | tr '\n' ' '
  )

  # Séparer "Machine" (kind=ssh) et "non-Machine" pour les existants
  declare -a current_non_machine=()
  declare -a current_machine=()
  declare -A seen_ids=()

  local cid kind
  for cid in ${current_cred_ids}; do
    [[ -z "$cid" || -n "${seen_ids[$cid]+x}" ]] && continue
    kind="$(cred_kind "$cid")"
    if [[ "$kind" == "ssh" ]]; then
      current_machine+=("$cid")
    else
      current_non_machine+=("$cid")
    fi
    seen_ids["$cid"]=1
  done

  # Traiter les -K passés en ligne: séparer Machine vs non-Machine
  declare -a provided_machine=()
  declare -a provided_non_machine=()
  if [[ -n "${cred_ids_ws}" ]]; then
    local pid pkind
    for pid in ${cred_ids_ws}; do
      [[ -z "$pid" ]] && continue
      pkind="$(cred_kind "$pid")"
      if [[ "$pkind" == "ssh" ]]; then
        provided_machine+=("$pid")
      else
        provided_non_machine+=("$pid")
      fi
      # (pas de dédup ici; on fera une dédup finale)
    done
  fi

  # Politique:
  # - Machine: si au moins un fourni -> REPLACE (ignorer current_machine), prendre le 1er fourni
  #            sinon -> GARDER current_machine
  # - Non-Machine: union de current_non_machine ∪ provided_non_machine
  declare -a final_creds=()
  declare -A final_seen=()

  for cid in "${current_non_machine[@]}"; do
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  done
  for cid in "${provided_non_machine[@]}"; do
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  done

  if ((${#provided_machine[@]} > 0)); then
    cid="${provided_machine[0]}"
    [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
  else
    for cid in "${current_machine[@]}"; do
      [[ -n "$cid" && -z "${final_seen[$cid]+x}" ]] && { final_creds+=("$cid"); final_seen["$cid"]=1; }
    done
  fi

  # Construire la liste CSV pour --credentials (un seul flag)
  local creds_csv=""
  if ((${#final_creds[@]})); then
    local IFS=,
    creds_csv="${final_creds[*]}"
  fi

  # -------------------- Construire la commande de lancement -------------------
  local args=( job_templates launch "${tpl_id}" --inventory "${inv_id}" -f json --conf.color False )
  [[ -n "${extra_arg}" ]] && args+=( --extra_vars "${extra_arg}" )
  [[ -n "${creds_csv}" ]] && args+=( --credentials "${creds_csv}" )
  [[ -n "${verbosity_level}" ]] && args+=( --verbosity "${verbosity_level}" )

  # -------------------- Lancement + attente (silencieuse ou monitor) ---------
  local job_json job_id status
  job_json=$(awx "${args[@]}" </dev/null)
  job_id=$(printf '%s' "${job_json}" | jq -r '.id // empty')
  [[ -z "${job_id}" ]] && { echo "Échec du lancement du job." >&2; printf '%s\n' "${job_json}" >&2; return 1; }

  if [[ "${verbose}" == "true" ]]; then
    echo "Job lancé: id=${job_id}. Affichage en direct…"
    awx jobs monitor "${job_id}" --conf.color False </dev/null || true
    status="$(awx jobs get "${job_id}" -f json --conf.color False </dev/null | jq -r '.status // empty')"
  else
    echo "Job lancé: id=${job_id}. Attente silencieuse de la fin…"
    while :; do
      status=$(awx jobs get "${job_id}" -f json --conf.color False </dev/null | jq -r '.status // empty')
      case "$status" in
        successful|failed|error|canceled) break ;;
        *) sleep 2 ;;
      esac
    done
  fi

  local job_ok=0
  if [[ "$status" == "successful" ]]; then
    echo "Statut final du job ${job_id}: successful."
  else
    echo "Statut final du job ${job_id}: ${status}." >&2
    job_ok=1
  fi

  # -------------------- Failed hosts (affichage / destination) ----------------
  if [[ "${show_failed}" == "true" ]]; then
    echo "Hôtes en échec pour le job ${job_id}:"
    print_failed_hosts "${job_id}"
  fi

  if [[ -n "${failed_dest}" ]]; then
    echo "Collecte des failed-hosts du job pour alimentation de '${failed_dest}'…"
    mapfile -t FAILED_HOSTS < <(collect_failed_hosts_from_job "${job_id}" | sort -u)
    if ((${#FAILED_HOSTS[@]})); then
      local dest_inv_id
      dest_inv_id=$(awx inventories list --name "${failed_dest}" --organization "${org_id}" -f json --conf.color False </dev/null | first_id || true)
      [[ -z "${dest_inv_id}" ]] && dest_inv_id=$(create_inventory "${org_id}" "${failed_dest}")
      [[ "${purge_dest}" == "true" ]] && purge_inventory_hosts "${dest_inv_id}"
      local dest_group_id=""
      [[ -n "${dest_group}" ]] && dest_group_id=$(ensure_group "${dest_inv_id}" "${dest_group}")
      add_hosts_into_inventory "${dest_inv_id}" "${dest_group_id}" "${FAILED_HOSTS[@]}"  # fallback per-host OK ici
    else
      echo "Aucun failed-host détecté pour ce job."
    fi
  fi

  return ${job_ok}
}
-----------------------------------------
1-
  -Jq, --show-stdout-noskips JOB_ID
                           Afficher le stdout d'un job en filtrant les lignes 'skipping'

2-
SHOW_STDOUT_NOSKIPS_JOB_ID=""

3-
    -Jq|--show-stdout-noskips) SHOW_STDOUT_NOSKIPS_JOB_ID="${2:?}"; shift 2 ;;

4-

if [[ -n "${SHOW_STDOUT_NOSKIPS_JOB_ID}" ]]; then
  if ! show_job_stdout_no_skips "${SHOW_STDOUT_NOSKIPS_JOB_ID}"; then
    echo "Impossible d'afficher le stdout (sans skips) pour le job ${SHOW_STDOUT_NOSKIPS_JOB_ID}." >&2
    exit 1
  fi
  exit 0
fi

5-
show_job_stdout_no_skips() {
  # $1 = job_id
  local job_id="${1:?usage: show_job_stdout_no_skips <job_id>}"
  local out=""

  # 1) Essai via CLI puis filtrage
  if out="$(awx jobs stdout "${job_id}" --conf.color False </dev/null 2>/dev/null)"; then
    # Filtre les lignes contenant "skipping" (insensible à la casse)
    # - utilise grep -vi pour ignorer ces lignes; si tout est filtré, renvoie rien mais succès.
    printf '%s\n' "$out" | grep -vi 'skipping' || true
    return 0
  fi

  # 2) Fallback API: /api/v2/jobs/<id>/stdout/?format=txt_download
  local base="${URL%/}"
  local url="${base}/api/v2/jobs/${job_id}/stdout/?format=txt_download"
  if out="$(_aap_curl_json "${url}" 2>/dev/null)"; then
    printf '%s\n' "$out" | grep -vi 'skipping' || true
    return 0
  fi

  return 1
}


-----------------------------
show_job_stdout_no_skips() {
  # $1 = job_id
  local job_id="${1:?usage: show_job_stdout_no_skips <job_id>}"

  awx jobs stdout "${job_id}" --conf.color False </dev/null | awk '
    BEGIN {
      in_task = 0; keep = 0; header = ""; buf = ""
    }
    # Fonction pour vider la tâche en cours (imprimer seulement si non 100% skipped)
    function flush() {
      if (in_task) {
        if (keep) {
          print header
          printf "%s", buf
        }
        in_task = 0; keep = 0; header = ""; buf = ""
      }
    }
    # Début d une tâche
    /^TASK \[/ {
      flush()
      in_task = 1; keep = 0
      header = $0
      next
    }
    # Frontières hors-tâche (nouveau PLAY, RECAP, handlers, meta, includes, etc.)
    /^(PLAY( |$)|PLAY RECAP|RUNNING HANDLER|RUNNING HANDLERS|HANDLER \[|META:|Including:|including:|INCLUDE TASKS)/ {
      flush()
      print $0
      next
    }
    {
      if (in_task) {
        # On conserve uniquement les lignes NON "skipping" (insensible à la casse)
        if ($0 !~ /[Ss][Kk][Ii][Pp]/) {
          keep = 1
          buf = buf $0 ORS
        }
      } else {
        # Hors tâche: on imprime tel quel
        print $0
      }
    }
    END {
      flush()
    }
  '
}

-----------------------

TAGS_RAW=()
SKIP_TAGS_RAW=()
TAGS=()
SKIP_TAGS=()
TAGS_CSV=""
SKIP_TAGS_CSV=""


    --tags)       TAGS_RAW+=("${2:?}"); shift 2 ;;
    --skip-tags)  SKIP_TAGS_RAW+=("${2:?}"); shift 2 ;;
-----
normalize_csv_list -u TAGS      "${TAGS_RAW[@]}"
normalize_csv_list -u SKIP_TAGS "${SKIP_TAGS_RAW[@]}"

if ((${#TAGS[@]})); then
  IFS=, read -r -a _ <<< "${TAGS[*]}"; TAGS_CSV="${_*}"; unset _
  IFS=, TAGS_CSV="${TAGS[*]}"
fi
if ((${#SKIP_TAGS[@]})); then
  IFS=, SKIP_TAGS_CSV="${SKIP_TAGS[*]}"
fi
---


launch_template_with_inventory \
  "${TEMPLATE_ARG}" "${INV_ID}" \
  "${EXTRA_VARS}" "${SHOW_FAILED}" \
  "${FAILED_DEST_NAME}" "${PURGE_DEST}" \
  "${ORG_ID}" "${GROUP:-}" \
  "${VERBOSE}" \
  "${CRED_IDS[*]}" \
  "${VERBOSITY_LEVEL}" \
  "${TAGS_CSV}" "${SKIP_TAGS_CSV}"
--

launch_template_with_inventory \
  "${TEMPLATE_ARG}" "${TEMP_INV_ID}" \
  "${EXTRA_VARS}" "${SHOW_FAILED}" \
  "${FAILED_DEST_NAME}" "${PURGE_DEST}" \
  "${ORG_ID}" "${GROUP:-}" \
  "${VERBOSE}" \
  "${CRED_IDS[*]}" \
  "${VERBOSITY_LEVEL}" \
  "${TAGS_CSV}" "${SKIP_TAGS_CSV}"

---
launch_template_with_inventory() {
  # ... commentaires existants ...
  # $10 = credential IDs "12 34"
  # $11 = verbosity level "0..5"
  # $12 = tags_csv (ex: "tag1,tag2")
  # $13 = skip_tags_csv (ex: "never,debug")
  local template_arg="$1" inv_id="$2" extra_vars="$3" show_failed="$4" failed_dest="$5" purge_dest="$6" org_id="$7" dest_group="$8" verbose="${9:-false}"
  shift 9
  local cred_ids_ws="${1:-}"; shift || true
  local verbosity_level="${1:-}"; shift || true
  local tags_csv="${1:-}"; shift || true
  local skip_tags_csv="${1:-}"
--

  [[ -n "${tags_csv}" ]]       && args+=( --tags "${tags_csv}" )
  [[ -n "${skip_tags_csv}" ]]  && args+=( --skip_tags "${skip_tags_csv}" )
