#!/usr/bin/env bash
# aap_load_inventory_awx.sh — Pilotage AWX/AAP (inventaires, templates, bulk hosts, failed-hosts)
# Dépendances: awx (awxkit), jq, curl
set -euo pipefail

# --- Localiser & sourcer les fonctions --------------------------------------
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
HELPERS="${SCRIPT_DIR}/aap_helpers.sh"
if [[ ! -f "${HELPERS}" ]]; then
  echo "Helpers introuvables: ${HELPERS}" >&2
  exit 1
fi
# shellcheck source=./aap_helpers.sh
source "${HELPERS}"

usage() {
  cat <<'EOF'
Usage:
  aap_load_inventory_awx.sh -u https://aap.example.com -o ORG_NAME [-i INVENTORY_NAME] \
    [-f servers.txt] [-H host1,host2 -H host3] \
    [-t TOKEN | -U USER -P PASS] [-g GROUP] \
    [-X] [-C] [-L] \
    [-T TEMPLATE_NAME_OR_ID] [-E "k=v ..."|@file.yml] [-F] [-D FAILED_DEST_NAME [--purge-dest]] \
    [-B NEW_INV_FROM_FAILED [--purge-dest]] \
    [-P INVENTORY_TO_PURGE] \
    [-K ID|-K ID,ID2 ...] [-v] [--verbosity LEVEL] [-J JOB_ID] \
    [-h]

Obligatoire:
  -u  URL du Controller AAP/Tower (ex: https://aap.example.com)
  -o  Nom de l'organisation (ex: Default)

Inventaire:
  -i  Nom de l'inventaire (si absent et -T, un inventaire temporaire est créé)
  -g  (Optionnel) Créer/trouver un groupe et y associer les hôtes ajoutés
  -f  Fichier texte (un hôte par ligne) à ajouter
  -H  Hôte(s) via CLI; utilisable plusieurs fois ou virgule-séparé (ex: -H web1,web2 -H db1)

Authentification (choisir UNE méthode):
  -t  Personal Access Token (Bearer)
  -U  Nom d'utilisateur (si pas de token)
  -P  Mot de passe (si pas de token)

Modes spéciaux:
  -X, --delete             Supprimer l'inventaire ciblé (-i) puis quitter
  -C, --check              Vérifier existence (-i) + afficher nombre d'hôtes, puis quitter
  -L, --list-hosts         Lister les hôtes de l'inventaire (-i), puis quitter

  -T, --template NAME|ID   Lancer le Job Template (par nom ou id).
                           Si -i absent, crée un inventaire temporaire, ajoute -f/-H si fournis,
                           lance, attend la fin (silencieux par défaut), puis supprime l'inventaire temporaire.
  -E, --extra-vars EVARS   Extra-vars pour le lancement du template (ex: -E "env=prod ver=1.2.3" ou -E @vars.yml)
  -F, --failed-hosts       Après -T, afficher la liste des hôtes en échec (job events/summaries)
  -D, --failed-dest NAME   Après -T, créer/compléter l'inventaire NAME avec les failed-hosts du job
                           (fonctionne avec --purge-dest et -g)

  -B, --build-from-failed NAME
                           Créer/compléter l'inventaire NAME avec les failed-hosts de l'inventaire source (-i requis)
                           Option: --purge-dest pour vider l'inventaire NAME avant remplissage

  -P, --purge-inventory NAME
                           Purger (vider) l'inventaire NAME (supprimer tous ses hôtes) puis quitter

Options supplémentaires:
  -K, --credential ID      Associer un credential ID au lancement du template (répétable ou virgule-séparé)
  -v, --verbose            Afficher le stdout du job en direct (monitor). Par défaut: attente silencieuse.
      --verbosity LEVEL    Niveau de verbosité au lancement (-T). Ex: 0..5
  -J, --show-stdout JOB_ID Afficher le stdout d'un job existant (ne lance rien)
  --purge-dest             À utiliser avec -B ou -D: vide l'inventaire destination avant remplissage
  -h, --help               Afficher cette aide

Exemples:
  aap_load_inventory_awx.sh -u https://aap -o Default -i MyInv -T "Deploy" -t "$AAP_TOKEN" --verbosity 2
  aap_load_inventory_awx.sh -u https://aap -o Default -f hosts.txt -T 42 -t "$AAP_TOKEN" -v -K 12,34
  aap_load_inventory_awx.sh -u https://aap -o Default -i Prod -B "Failed-PRD" -t "$AAP_TOKEN" --purge-dest
  aap_load_inventory_awx.sh -u https://aap -o Default -J 12345 -t "$AAP_TOKEN"
EOF
}

# --- Variables d'options -----------------------------------------------------
URL="" ORG_NAME="" INV_NAME=""
HOST_FILE=""
TOKEN="" USER="" PASS="" GROUP=""
DELETE_MODE="false"
CHECK_MODE="false"
LIST_MODE="false"
TEMPLATE_ARG=""
EXTRA_VARS=""
SHOW_FAILED="false"
FAILED_DEST_NAME=""
BUILD_FROM_FAILED=""
PURGE_DEST="false"
PURGE_ONLY_NAME=""
CLI_HOSTS_RAW=()
CLI_HOSTS=()
CRED_IDS_RAW=()
CRED_IDS=()
VERBOSE="false"
VERBOSITY_LEVEL=""
SHOW_STDOUT_JOB_ID=""

# --- Parse options -----------------------------------------------------------
while (( $# )); do
  case "$1" in
    -u) URL="${2:?}"; shift 2 ;;
    -o) ORG_NAME="${2:?}"; shift 2 ;;
    -i) INV_NAME="${2:?}"; shift 2 ;;
    -f) HOST_FILE="${2:?}"; shift 2 ;;
    -H|--host) CLI_HOSTS_RAW+=("${2:?}"); shift 2 ;;
    -t) TOKEN="${2:?}"; shift 2 ;;
    -U) USER="${2:?}"; shift 2 ;;
    -P) PASS="${2:?}"; shift 2 ;;
    -g) GROUP="${2:?}"; shift 2 ;;
    -X|--delete) DELETE_MODE="true"; shift ;;
    -C|--check)  CHECK_MODE="true";  shift ;;
    -L|--list-hosts) LIST_MODE="true"; shift ;;
    -T|--template) TEMPLATE_ARG="${2:?}"; shift 2 ;;
    -E|--extra-vars) EXTRA_VARS="${2:-}"; shift 2 ;;
    -F|--failed-hosts) SHOW_FAILED="true"; shift ;;
    -D|--failed-dest) FAILED_DEST_NAME="${2:?}"; shift 2 ;;
    -B|--build-from-failed) BUILD_FROM_FAILED="${2:?}"; shift 2 ;;
    --purge-dest) PURGE_DEST="true"; shift ;;
    -P|--purge-inventory) PURGE_ONLY_NAME="${2:?}"; shift 2 ;;
    -K|--credential) CRED_IDS_RAW+=("${2:?}"); shift 2 ;;
    -v|--verbose) VERBOSE="true"; shift ;;
    --verbosity) VERBOSITY_LEVEL="${2:?}"; shift 2 ;;
    -J|--show-stdout) SHOW_STDOUT_JOB_ID="${2:?}"; shift 2 ;;
    -h|--help) usage; exit 0 ;;
    --) shift; break ;;
    -*) echo "Option inconnue: $1" >&2; usage; exit 1 ;;
    *) break ;;
  esac
done

# --- Validations -------------------------------------------------------------
if [[ -z "${URL}" || -z "${ORG_NAME}" ]]; then
  echo "Erreur: -u et -o sont obligatoires." >&2
  usage; exit 1
fi
if [[ -z "${TOKEN}" && ( -z "${USER}" || -z "${PASS}" ) ]]; then
  echo "Erreur: fournissez -t TOKEN ou bien -U USER -P PASS." >&2
  exit 1
fi

# Normalisations
normalize_csv_list -u CLI_HOSTS "${CLI_HOSTS_RAW[@]}"
normalize_csv_list -u CRED_IDS  "${CRED_IDS_RAW[@]}"

# Si hors modes spéciaux, exiger -i et au moins -f/-H
if [[ "${DELETE_MODE}" != "true" && "${CHECK_MODE}" != "true" && "${LIST_MODE}" != "true" && -z "${TEMPLATE_ARG}" && -z "${BUILD_FROM_FAILED}" && -z "${PURGE_ONLY_NAME}" && -z "${SHOW_STDOUT_JOB_ID}" ]]; then
  if [[ -z "${INV_NAME}" ]]; then
    echo "Erreur: sans -T/-X/-C/-L/-B/-P/-J, vous devez préciser -i INVENTORY_NAME." >&2
    usage; exit 1
  fi
  if [[ -z "${HOST_FILE}" && ${#CLI_HOSTS[@]} -eq 0 ]]; then
    echo "Erreur: sans -T/-X/-C/-L/-B/-P/-J, spécifiez au moins -f ou -H pour ajouter des hôtes." >&2
    usage; exit 1
  fi
  if [[ -n "${HOST_FILE}" && ! -f "${HOST_FILE}" ]]; then
    echo "Erreur: fichier hôtes introuvable: ${HOST_FILE}" >&2
    exit 1
  fi
fi

# --- Prérequis ---------------------------------------------------------------
command -v awx  >/dev/null || { echo "Erreur: 'awx' (awxkit) non trouvé (pip install awxkit)"; exit 1; }
command -v jq   >/dev/null || { echo "Erreur: 'jq' non trouvé"; exit 1; }
command -v curl >/dev/null || { echo "Erreur: 'curl' non trouvé"; exit 1; }

# --- Auth AWX ---------------------------------------------------------------
if [[ -n "${TOKEN}" ]]; then
  awx --conf.host "${URL}" --conf.token "${TOKEN}" --conf.color False ping >/dev/null
else
  awx login --conf.host "${URL}" --username "${USER}" --password "${PASS}" >/dev/null
fi
export AWX_CLI_NOPAGER=1
export AWX_CLI_NOCOLOR=1
# exposer aux helpers API:
export URL TOKEN USER PASS

# --- 1) ORG ------------------------------------------------------------------
ORG_ID=$(awx organizations list --name "${ORG_NAME}" -f json --conf.color False </dev/null | first_id)
if [[ -z "${ORG_ID}" ]]; then
  echo "Erreur: organisation '${ORG_NAME}' introuvable sur ${URL}" >&2
  exit 1
fi
echo "Organisation: ${ORG_NAME} (id=${ORG_ID})"

# --- 2) INVENTORY lookup (source si fourni) ----------------------------------
INV_ID=""
if [[ -n "${INV_NAME}" ]]; then
  INV_ID=$(awx inventories list --name "${INV_NAME}" --organization "${ORG_ID}" -f json --conf.color False </dev/null | first_id || true)
fi

# =========================== MODES AUTONOMES =================================

# Affichage stdout d'un job existant
if [[ -n "${SHOW_STDOUT_JOB_ID}" ]]; then
  if ! show_job_stdout "${SHOW_STDOUT_JOB_ID}"; then
    echo "Impossible d'afficher le stdout pour le job ${SHOW_STDOUT_JOB_ID}." >&2
    exit 1
  fi
  exit 0
fi

# Purge inventaire par nom
if [[ -n "${PURGE_ONLY_NAME}" ]]; then
  DEST_INV_ID=$(awx inventories list --name "${PURGE_ONLY_NAME}" --organization "${ORG_ID}" -f json --conf.color False </dev/null | first_id || true)
  if [[ -z "${DEST_INV_ID}" ]]; then
    echo "Inventaire '${PURGE_ONLY_NAME}' introuvable (org=${ORG_NAME})." >&2
    exit 2
  fi
  purge_inventory_hosts "${DEST_INV_ID}"
  exit 0
fi

# Lister hôtes
if [[ "${LIST_MODE}" == "true" ]]; then
  if [[ -z "${INV_ID}" ]]; then
    echo "Inventaire '${INV_NAME}' introuvable (org=${ORG_NAME})." >&2
    exit 2
  fi
  echo "Hôtes de l'inventaire '${INV_NAME}' (id=${INV_ID}):"
  awx hosts list --inventory "${INV_ID}" -f json --conf.color False </dev/null | list_names
  exit 0
fi

# Check inventaire
if [[ "${CHECK_MODE}" == "true" ]]; then
  if [[ -z "${INV_ID}" ]]; then
    echo "Inventaire '${INV_NAME}' introuvable (org=${ORG_NAME})."
    exit 2
  fi
  HOSTS_JSON=$(awx hosts list --inventory "${INV_ID}" -f json --conf.color False </dev/null)
  HOSTS_COUNT=$(printf '%s' "${HOSTS_JSON}" | count_items)
  echo "Inventaire '${INV_NAME}' existe (id=${INV_ID})."
  echo "Nombre d'hôtes: ${HOSTS_COUNT}"
  exit 0
fi

# Delete inventaire
if [[ "${DELETE_MODE}" == "true" ]]; then
  if [[ -z "${INV_ID}" ]]; then
    echo "Inventaire '${INV_NAME}' introuvable (org=${ORG_NAME}). Rien à supprimer."
    exit 0
  fi
  echo "Suppression de l'inventaire '${INV_NAME}' (id=${INV_ID})…"
  if ! awx inventories delete "${INV_ID}" --conf.color False </dev/null; then
    echo "Échec de suppression (inventaire référencé ?)." >&2
    exit 1
  fi
  echo "Inventaire supprimé."
  exit 0
fi

# Build-from-failed (depuis inventaire source -i)
if [[ -n "${BUILD_FROM_FAILED}" ]]; then
  if [[ -z "${INV_NAME}" || -z "${INV_ID}" ]]; then
    echo "Erreur: -B nécessite un inventaire source via -i (et existant)." >&2
    exit 1
  fi
  echo "Extraction des failed-hosts depuis '${INV_NAME}' (id=${INV_ID})…"
  mapfile -t FAILED_HOSTS < <(failed_host_names_from_inventory "${INV_ID}" | sort -u)
  if ((${#FAILED_HOSTS[@]}==0)); then
    echo "Aucun failed-host détecté."
    exit 0
  fi

  DEST_INV_ID=$(awx inventories list --name "${BUILD_FROM_FAILED}" --organization "${ORG_ID}" -f json --conf.color False </dev/null | first_id || true)
  if [[ -z "${DEST_INV_ID}" ]]; then
    echo "Création de l'inventaire destination '${BUILD_FROM_FAILED}'…"
    DEST_INV_ID=$(create_inventory "${ORG_ID}" "${BUILD_FROM_FAILED}")
    [[ -z "${DEST_INV_ID}" ]] && { echo "Échec de création destination." >&2; exit 1; }
  else
    echo "Inventaire destination trouvé: '${BUILD_FROM_FAILED}' (id=${DEST_INV_ID})"
  fi

  if [[ "${PURGE_DEST}" == "true" ]]; then
    purge_inventory_hosts "${DEST_INV_ID}"
  fi

  DEST_GROUP_ID=""
  if [[ -n "${GROUP}" ]]; then
    DEST_GROUP_ID=$(ensure_group "${DEST_INV_ID}" "${GROUP}")
  fi

  echo "Ajout de ${#FAILED_HOSTS[@]} failed-host(s) dans '${BUILD_FROM_FAILED}'…"
  bulk_add_hosts_into_inventory "${DEST_INV_ID}" "${DEST_GROUP_ID:-}" "${FAILED_HOSTS[@]}"
  echo "Terminé."
  exit 0
fi

# ============================ MODE TEMPLATE ==================================

_build_final_hosts_array() {
  local -n _out_arr="$1"
  _out_arr=()
  if [[ -n "${HOST_FILE}" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      line="${line%%[$'\r\n']}"
      [[ -z "$line" || "$line" =~ ^# ]] && continue
      _out_arr+=("$line")
    done < "${HOST_FILE}"
  fi
  if ((${#CLI_HOSTS[@]})); then
    _out_arr+=("${CLI_HOSTS[@]}")
  fi
}

if [[ -n "${TEMPLATE_ARG}" ]]; then
  if [[ -n "${INV_NAME}" ]]; then
    if [[ -z "${INV_ID}" ]]; then
      echo "Inventaire '${INV_NAME}' introuvable (org=${ORG_NAME})." >&2
      exit 2
    fi
    echo "Utilisation de l'inventaire existant id=${INV_ID} ('${INV_NAME}')"

    GROUP_ID=""
    if [[ -n "${GROUP}" ]]; then
      GROUP_ID=$(ensure_group "${INV_ID}" "${GROUP}")
      echo "Groupe '${GROUP}' id=${GROUP_ID}"
    fi

    FINAL_HOSTS=()
    _build_final_hosts_array FINAL_HOSTS
    if ((${#FINAL_HOSTS[@]})); then
      echo "Ajout/validation préalable de ${#FINAL_HOSTS[@]} hôte(s)…"
      bulk_add_hosts_into_inventory "${INV_ID}" "${GROUP_ID:-}" "${FINAL_HOSTS[@]}"
    fi

    launch_template_with_inventory \
      "${TEMPLATE_ARG}" "${INV_ID}" \
      "${EXTRA_VARS}" "${SHOW_FAILED}" \
      "${FAILED_DEST_NAME}" "${PURGE_DEST}" \
      "${ORG_ID}" "${GROUP:-}" \
      "${VERBOSE}" \
      "${CRED_IDS[*]}" \
      "${VERBOSITY_LEVEL}"
    exit $?
  else
    # inventaire temporaire
    TS=$(date +%Y%m%d-%H%M%S)
    TEMP_INV_NAME="TMP-${TEMPLATE_ARG// /_}-${TS}"
    echo "Création d'un inventaire temporaire '${TEMP_INV_NAME}'…"
    TEMP_INV_ID=$(create_inventory "${ORG_ID}" "${TEMP_INV_NAME}")
    if [[ -z "${TEMP_INV_ID}" ]]; then
      echo "Échec création inventaire temporaire." >&2
      exit 1
    fi
    echo "Inventaire temporaire id=${TEMP_INV_ID}"

    TEMP_GROUP_ID=""
    if [[ -n "${GROUP}" ]]; then
      TEMP_GROUP_ID=$(ensure_group "${TEMP_INV_ID}" "${GROUP}")
      echo "Groupe '${GROUP}' id=${TEMP_GROUP_ID}"
    fi

    FINAL_HOSTS=()
    _build_final_hosts_array FINAL_HOSTS
    if ((${#FINAL_HOSTS[@]})); then
      echo "Ajout/validation préalable de ${#FINAL_HOSTS[@]} hôte(s) dans l'inventaire temporaire…"
      bulk_add_hosts_into_inventory "${TEMP_INV_ID}" "${TEMP_GROUP_ID:-}" "${FINAL_HOSTS[@]}"
    fi

    JOB_OK=0
    if ! launch_template_with_inventory \
          "${TEMPLATE_ARG}" "${TEMP_INV_ID}" \
          "${EXTRA_VARS}" "${SHOW_FAILED}" \
          "${FAILED_DEST_NAME}" "${PURGE_DEST}" \
          "${ORG_ID}" "${GROUP:-}" \
          "${VERBOSE}" \
          "${CRED_IDS[*]}" \
          "${VERBOSITY_LEVEL}"; then
      JOB_OK=1
    fi

    echo "Nettoyage: suppression de l'inventaire temporaire id=${TEMP_INV_ID}…"
    awx inventories delete "${TEMP_INV_ID}" --conf.color False </dev/null || true
    exit ${JOB_OK}
  fi
fi

# ========================== GESTION D'INVENTAIRE =============================

if [[ -z "${INV_NAME}" ]]; then
  echo "Erreur: mode gestion inventaire requiert -i INVENTORY_NAME." >&2
  usage; exit 1
fi

if [[ -z "${INV_ID}" ]]; then
  echo "Inventaire '${INV_NAME}' absent. Création…"
  INV_ID=$(create_inventory "${ORG_ID}" "${INV_NAME}")
  if [[ -z "${INV_ID}" ]]; then
    echo "Échec de création de l'inventaire." >&2
    exit 1
  fi
  echo "Inventaire créé: id=${INV_ID}"
else
  echo "Inventaire trouvé: '${INV_NAME}' (id=${INV_ID})"
fi

GROUP_ID=""
if [[ -n "${GROUP}" ]]; then
  GROUP_ID=$(ensure_group "${INV_ID}" "${GROUP}")
  echo "Groupe '${GROUP}' id=${GROUP_ID}"
fi

FINAL_HOSTS=()
_build_final_hosts_array FINAL_HOSTS
if ((${#FINAL_HOSTS[@]}==0)); then
  echo "Aucun hôte à ajouter (ni -f ni -H)." >&2
  exit 0
fi

echo "Ajout/validation des hôtes (${#FINAL_HOSTS[@]})…"
bulk_add_hosts_into_inventory "${INV_ID}" "${GROUP_ID:-}" "${FINAL_HOSTS[@]}"

echo "Terminé."


-----------------
helpers:

# Résout l'ID d'un job template à partir d'un nom ou d'un ID
resolve_template_id() {
  local tpl="$1" tid=""
  if [[ "$tpl" =~ ^[0-9]+$ ]]; then
    tid="$tpl"
  else
    tid=$(awx job_templates list --name "$tpl" -f json --conf.color False </dev/null | first_id || true)
  fi
  [[ -n "$tid" ]] && printf '%s' "$tid"
}

# Renvoie le champ extra_vars brut (chaîne YAML/JSON) d'un JT
jt_get_extra_vars_raw() {
  local tpl_id="${1:?usage: jt_get_extra_vars_raw <template_id>}"
  awx job_templates get "$tpl_id" -f json --conf.color False </dev/null | jq -r '.extra_vars // ""'
}

# Affiche extra_vars: brut + pretty JSON si possible
jt_show_vars() {
  local tpl="${1:?usage: jt_show_vars <name|id>}"
  local tid; tid=$(resolve_template_id "$tpl") || true
  [[ -z "$tid" ]] && { echo "Template '$tpl' introuvable." >&2; return 1; }

  local raw; raw=$(jt_get_extra_vars_raw "$tid")
  echo "# --- extra_vars (brut) ---"
  printf '%s\n' "$raw"

  # Tentative parse JSON
  if jq -e . >/dev/null 2>&1 <<<"$raw"; then
    echo "# --- extra_vars (JSON pretty) ---"
    jq . <<<"$raw"
  else
    echo "# (non-JSON : probablement YAML ; pas de pretty sans parseur YAML)" >&2
  fi
}

# Merge (ajout/remplacement) des extra_vars du JT avec un objet JSON fourni (ou @file)
# Si l'existant n'est pas JSON: remplacement total si input = @file ; sinon erreur.
jt_merge_vars() {
  local tpl="${1:?usage: jt_merge_vars <name|id> <json_or_@file>}" inp="${2:?}"
  local tid; tid=$(resolve_template_id "$tpl") || true
  [[ -z "$tid" ]] && { echo "Template '$tpl' introuvable." >&2; return 1; }

  local raw; raw=$(jt_get_extra_vars_raw "$tid")

  # Charger l'input
  local in_str=""
  if [[ "$inp" == @* ]]; then
    local path="${inp#@}"
    [[ -f "$path" ]] || { echo "Fichier non trouvé: $path" >&2; return 1; }
    in_str="$(<"$path")"
  else
    in_str="$inp"
  fi

  # Si l'existant est JSON -> merge. Sinon:
  # - si input via fichier -> on remplace totalement avec --extra_vars @file
  # - sinon -> erreur (demander un fichier)
  if jq -e . >/dev/null 2>&1 <<<"$raw"; then
    # Existant JSON
    if ! jq -e . >/dev/null 2>&1 <<<"$in_str"; then
      echo "L'input n'est pas du JSON valide. Fournis un JSON ou un fichier @vars.yml pour remplacer." >&2
      return 1
    fi
    local merged
    merged=$(jq -c --argjson base "$raw" --argjson add "$in_str" '$base + $add' <<<"null")
    awx job_templates modify "$tid" --extra_vars "$merged" --conf.color False >/dev/null
  else
    # Existant non-JSON (YAML probable)
    if [[ "$inp" == @* ]]; then
      awx job_templates modify "$tid" --extra_vars "$inp" --conf.color False >/dev/null
    else
      echo "Les variables existantes ne sont pas JSON. Utilise un fichier: --jt-vars-merge @vars.yml (remplacement complet)." >&2
      return 1
    fi
  fi
  echo "OK: variables du template mises à jour."
}

# Supprime une liste de clés (JSON uniquement). Exemple: jt_unset_vars myJT "k1,k2"
jt_unset_vars() {
  local tpl="${1:?usage: jt_unset_vars <name|id> <key1,key2,...>}" keys_csv="${2:?}"
  local tid; tid=$(resolve_template_id "$tpl") || true
  [[ -z "$tid" ]] && { echo "Template '$tpl' introuvable." >&2; return 1; }

  local raw; raw=$(jt_get_extra_vars_raw "$tid")
  jq -e . >/dev/null 2>&1 <<<"$raw" || { echo "extra_vars non-JSON (YAML ?). La suppression ciblée nécessite du JSON." >&2; return 1; }

  # Construire une expression jq del(.k1, .k2, ...)
  local del_expr="."
  local IFS=, key
  for key in $keys_csv; do
    key="${key//\"/\\\"}"
    del_expr="${del_expr} | del(.\"${key}\")"
  done
  local updated
  updated=$(jq -c "$del_expr" <<<"$raw")
  awx job_templates modify "$tid" --extra_vars "$updated" --conf.color False >/dev/null
  echo "OK: clés supprimées: ${keys_csv}"
}
-------------------------

JT_VARS_SHOW=""
JT_VARS_MERGE=""
JT_VARS_UNSET=""
----

    --jt-vars-show)  JT_VARS_SHOW="${2:?}";  shift 2 ;;
    --jt-vars-merge) JT_VARS_MERGE="${2:?}"; shift 2 ;;
    --jt-vars-unset) JT_VARS_UNSET="${2:?}"; shift 2 ;;

---

# ---- Gestion des variables d'un Job Template (modes autonomes) --------------
if [[ -n "${JT_VARS_SHOW}" ]]; then
  jt_show_vars "${JT_VARS_SHOW}" || { echo "Erreur lecture variables." >&2; exit 1; }
  exit 0
fi

if [[ -n "${JT_VARS_MERGE}" ]]; then
  # Requiert aussi --template pour savoir quel JT viser
  if [[ -z "${TEMPLATE_ARG}" ]]; then
    echo "Erreur: --jt-vars-merge nécessite aussi --template NAME|ID (pour cibler le JT)." >&2
    exit 1
  fi
  jt_merge_vars "${TEMPLATE_ARG}" "${JT_VARS_MERGE}" || { echo "Erreur merge variables." >&2; exit 1; }
  exit 0
fi

if [[ -n "${JT_VARS_UNSET}" ]]; then
  if [[ -z "${TEMPLATE_ARG}" ]]; then
    echo "Erreur: --jt-vars-unset nécessite aussi --template NAME|ID (pour cibler le JT)." >&2
    exit 1
  fi
  jt_unset_vars "${TEMPLATE_ARG}" "${JT_VARS_UNSET}" || { echo "Erreur suppression variables." >&2; exit 1; }
  exit 0
fi
---------------



# Affiche extra_vars d'un JT, au format demandé: "yaml" | "json" | "" (auto)
# Usage: jt_show_vars <name|id> [format]
jt_show_vars() {
  local tpl="${1:?usage: jt_show_vars <name|id> [yaml|json] }"
  local fmt="${2:-}"  # "yaml" | "json" | ""
  local tid; tid=$(resolve_template_id "$tpl") || true
  [[ -z "$tid" ]] && { echo "Template '$tpl' introuvable." >&2; return 1; }

  local raw; raw=$(jt_get_extra_vars_raw "$tid")

  # helper: est-ce du JSON valide ?
  if jq -e . >/dev/null 2>&1 <<<"$raw"; then
    local is_json=1
  else
    local is_json=0
  fi

  case "$fmt" in
    json)
      if (( is_json )); then
        jq . <<<"$raw"
        return 0
      fi
      # YAML -> JSON : tenter yq, sinon python3+PyYAML, sinon brut
      if command -v yq >/dev/null 2>&1; then
        yq -o=json - <<<"$raw"
      elif python3 - <<'PY' >/dev/null 2>&1 <<<"import yaml,sys; yaml.safe_load(sys.stdin.read())"; then
        python3 - <<'PY' <<<"$raw"
import sys, json
import yaml
print(json.dumps(yaml.safe_load(sys.stdin.read()), indent=2))
PY
      else
        echo "# (extra_vars non-JSON, conversion indisponible : affiche brut)" >&2
        printf '%s\n' "$raw"
      fi
      ;;

    yaml)
      if (( is_json )); then
        # JSON -> YAML : tenter yq, sinon python3+PyYAML, sinon brut
        if command -v yq >/dev/null 2>&1; then
          yq -p=json -o=yaml - <<<"$raw"
        elif python3 - <<'PY' >/dev/null 2>&1 <<<"import yaml,sys,json; yaml.safe_dump(json.loads(sys.stdin.read()))"; then
          python3 - <<'PY' <<<"$raw"
import sys, json, yaml
print(yaml.safe_dump(json.loads(sys.stdin.read()), sort_keys=False))
PY
        else
          echo "# (conversion JSON->YAML indisponible : affiche JSON pretty)" >&2
          jq . <<<"$raw"
        fi
      else
        # Déjà YAML : afficher tel quel
        printf '%s\n' "$raw"
      fi
      ;;

    ""|auto|Auto|AUTO)
      echo "# --- extra_vars (brut) ---"
      printf '%s\n' "$raw"
      if (( is_json )); then
        echo "# --- extra_vars (JSON pretty) ---"
        jq . <<<"$raw"
      else
        echo "# (non-JSON : probablement YAML ; pas de pretty JSON)" >&2
      fi
      ;;

    *)
      echo "Format inconnu: '$fmt' (attendu: yaml|json)" >&2
      return 2
      ;;
  esac
}

-----------
JT_VARS_SHOW=""
JT_VARS_MERGE=""
JT_VARS_UNSET=""
JT_VARS_SHOW_FMT=""

    --jt-vars-show)          JT_VARS_SHOW="${2:?}";        shift 2 ;;
    --jt-vars-show-format)   JT_VARS_SHOW_FMT="${2:?}";    shift 2 ;;
    --jt-vars-merge)         JT_VARS_MERGE="${2:?}";       shift 2 ;;
    --jt-vars-unset)         JT_VARS_UNSET="${2:?}";       shift 2 ;;


if [[ -n "${JT_VARS_SHOW}" ]]; then
  jt_show_vars "${JT_VARS_SHOW}" "${JT_VARS_SHOW_FMT}" || { echo "Erreur lecture variables." >&2; exit 1; }
  exit 0
fi
----------------


# Affiche extra_vars d'un JT, au format demandé: "yaml" | "json" | "" (auto)
# Usage: jt_show_vars <name|id> [yaml|json]
jt_show_vars() {
  local tpl="${1:?usage: jt_show_vars <name|id> [yaml|json] }"
  local fmt="${2:-}"  # "yaml" | "json" | ""
  local tid; tid=$(resolve_template_id "$tpl") || true
  [[ -n "$tid" ]] || { echo "Template '$tpl' introuvable." >&2; return 1; }

  local raw; raw=$(jt_get_extra_vars_raw "$tid")

  # Est-ce du JSON valide ?
  local is_json=0
  if jq -e . >/dev/null 2>&1 <<<"$raw"; then
    is_json=1
  fi

  case "$fmt" in
    json)
      if (( is_json )); then
        jq . <<<"$raw"
        return 0
      fi
      # YAML -> JSON : yq sinon python3+PyYAML sinon brut
      if command -v yq >/dev/null 2>&1; then
        yq -o=json - <<<"$raw"
      elif python3 -c 'import yaml' >/dev/null 2>&1; then
        python3 - <<'PY' <<<"$raw"
import sys, json
import yaml
print(json.dumps(yaml.safe_load(sys.stdin.read()), indent=2))
PY
      else
        echo "# (extra_vars non-JSON, conversion indisponible : affiche brut)" >&2
        printf '%s\n' "$raw"
      fi
      ;;

    yaml)
      if (( is_json )); then
        if command -v yq >/dev/null 2>&1; then
          yq -p=json -o=yaml - <<<"$raw"
        elif python3 -c 'import yaml, json' >/dev/null 2>&1; then
          python3 - <<'PY' <<<"$raw"
import sys, json, yaml
print(yaml.safe_dump(json.loads(sys.stdin.read()), sort_keys=False))
PY
        else
          echo "# (conversion JSON->YAML indisponible : affiche JSON pretty)" >&2
          jq . <<<"$raw"
        fi
      else
        # Déjà YAML : afficher tel quel
        printf '%s\n' "$raw"
      fi
      ;;

    ""|auto|Auto|AUTO)
      echo "# --- extra_vars (brut) ---"
      printf '%s\n' "$raw"
      if (( is_json )); then
        echo "# --- extra_vars (JSON pretty) ---"
        jq . <<<"$raw"
      else
        echo "# (non-JSON : probablement YAML ; pas de pretty JSON)" >&2
      fi
      ;;

    *)
      echo "Format inconnu: '$fmt' (attendu: yaml|json)" >&2
      return 2
      ;;
  esac
}

